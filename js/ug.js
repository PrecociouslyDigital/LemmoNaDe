function unparse(ar){if(ar.length==2&&(isQ(ar[0])||isU(ar[0]))){return ar[0]+unparse(ar[1])}if(ar.length==3&&isB(ar[1])){return"("+unparse(ar[0])+ar[1]+unparse(ar[2])+")"}else{return ar.join("")}}function parse(s){if(s==""){return[]}var s1=[];var s2=[];if(isQ(s)){s1=parse(s.substring(4));return s1.length?[s.substring(0,4),s1]:[]}if(isU(s[0])){s1=parse(s.substring(1));return s1.length?[s[0],s1]:[]}if(s[0]=="("&&s[s.length-1]==")"){var a=gSub(s);if(a.indexOf(undefined)>=0||a.indexOf("")>=0){return[]}else{s1=parse(a[0]);s2=parse(a[2]);if(s1.length&&s2.length){return[s1,a[1],s2]}else{return[]}}}else{return isA(s)?s.split(""):[]}}function isA(s){var pr="ABCDEFGHIJKLMNOPQRSTUVWXYZ";if(s.length==1&&isAbs(s)){return true}if(s.length==3&&isT(s[0])&&s[1]=="="&&isT(s[2])){return true}if(pr.indexOf(s[0])>=0){if(s.length==1){return true}else{for(var i=1;i<s.length;i++){if(!isT(s[i])){return false}}return true}}else{return false}}function isAbs(s){var abs=["#"];return abs.indexOf(s)>=0}function isQ(s){var q=["E","A"];if(s[0]=="("&&q.indexOf(s[1])>=0&&isV(s[2])&&s[3]==")"){return true}else{return false}}function isU(s){var u=["~"];for(var i=0;i<u.length;i++){if(s.indexOf(u[i])==0){return true}}return false}function gSub(s){var stk=[];var l=0;for(var i=0;i<s.length;i++){if(s[i]=="("){stk.push("(")}else if(s[i]==")"&&stk.length>0){stk.pop()}else if(stk.length==1&&(l=isB(s.substring(i)))>0){return[s.substring(1,i),s.substring(i,i+l),s.substring(i+l,s.length-1)]}}return[undefined,undefined,undefined]}function isB(s){var bc=["&","v",">","<>"];for(var i=0;i<bc.length;i++){if(s.indexOf(bc[i])==0){return bc[i].length}}return 0}function isT(c){return isC(c)||isV(c)}function isV(c){var cn="abcdefghijklmnopqrstuwxyz";return cn.indexOf(c)>=0}function isC(c){var cn="abcdefghijklmnopqrstuwxyz";return cn.indexOf(c)>=0}function richardify(s){if(isQ(s)){return"("+ptou(s[1])+s[2]+")"+richardify(s.substring(4,s.length))}else if(isU(s[0])){return ptou(s[0])+richardify(s.substring(1,s.length))}else if(s[0]=="("&&s[s.length-1]==")"){var a=gSub(s);return"("+richardify(a[0])+ptou(a[1])+richardify(a[2])+")"}else if(isAbs(s)){return ptou(s)}else{return s}}function latexify(s){var out="";var test="";for(var i=0;i<s.length;i++){test=utox(s[i]);if(test!=s[i]){test+=" "}out+=test}return out}function gRul(s){var out="";var c="";for(var i=0;i<s.length;i++){if(s[i]=="<"){c=ptou(s[i]+s[i+1]);i++}else if(s[i]=="E"||s[i]=="A"){c=i==0&&s.length==2?ptou(s[i]):s[i]}else{c=ptou(s[i])}out+=c}return out}function ptou(s){switch(s){case"v":return"∨";case"∨":return"v";case">":return"→";case"→":return">";case"<>":return"↔";case"↔":return"<>";case"#":return"⋏";case"⊥":return"#";case"A":return"∀";case"∀":return"A";case"E":return"∃";case"∃":return"E";default:return s}}function utox(c){switch(c){case"~":return"\\sim";case"&":return"\\&";case"∨":return"\\lor";case"→":return"\\rightarrow";case"↔":return"\\leftrightarrow";case"⋏":return"\\curlywedge";case"∀":return"\\forall";case"∃":return"\\exists";default:return c}}function padBC(str){var out="";var b=0;for(var i=0;i<str.length;i++){b=isB(str.substring(i));if(b==1){out=out+" "+str[i]+" "}else if(b==2){out=out+" "+str[i]+str[i+1]+" ";i=i+1}else{out=out+str[i]}}return out}function padBC2(s){var bc=["∨","→","↔","&"];var out="";for(var i=0;i<s.length;i++){if(bc.indexOf(s[i])>=0){out+=" "+s[i]+" "}else{out+=s[i]}}return out}function ckPA(d,f,t,r,s,l,n){if(d.length!=1||d[0]!=n+1){throw"[ERROR using Premise/Assumption rule]: Line must depend on itself (line "+(n+1)+") and nothing else."}if(l.length>0){throw"[ERROR using Premise/Assumption rule]: These rules can't be applied to any lines."}}function ckCJI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to lines "+l.join(",")+"]: ";if(l.length!=2){throw flag+"Rule must be applied to two lines."}if(t.length!=3||t[1]!="&"){throw flag+"The formula being derived must be a conjunction."}if(!(f=="("+frm[l[0]-1]+"&"+frm[l[1]-1]+")")&&!(f=="("+frm[l[1]-1]+"&"+frm[l[0]-1]+")")){throw flag+"The formulas on lines "+l[0]+" and "+l[1]+" must be the conjuncts of the formula being derived."}var a=sorted(rmDup(dep[l[0]-1].concat(dep[l[1]-1]))).join(",");if(d.join(",")!=a){throw flag+"dependencies are wrong. Remember: combine the dependencies of the two lines the rule is applied to."}}function ckCJE(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l.join(",")+"]: ";if(l.length!=1){throw flag+"Rule must be applied to one line."}if(tr[l[0]-1].length!=3||tr[l[0]-1][1]!="&"){throw flag+"The formula on line "+l[0]+" must be a conjunction."}if(!(f==unparse(tr[l[0]-1][0]))&&!(f==unparse(tr[l[0]-1][2]))){throw flag+"The formula being derived must be one of the conjuncts of the formula on line "+l[0]+"."}var a=dep[l[0]-1].join(",");if(d.join(",")!=a){throw"Using &E. dependencies are wrong. Remember: carry down the dependencies of the line the rule is applied to."}}function ckDJI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l.join(",")+"]: ";if(l.length!=1){throw flag+"Rule must be applied to one line"}if(t.length!=3||t[1]!="v"){throw flag+"The formula being derived must be a disjunction."}if(!(unparse(t[0])==frm[l[0]-1])&&!(unparse(t[2])==frm[l[0]-1])){throw flag+"The formula on line "+l[0]+" must be a disjunct of the formula being derived."}var a=dep[l[0]-1].join(",");if(d.join(",")!=a){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the line the rule is applied to."}}function ckDJE(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to lines "+l.join(",")+"]: ";if(l.length!=5){throw flag+"Rule must be applied to five lines."}if(tr[l[0]-1][1]!="v"){throw flag+"The first rule line must be the original disjunction."}if(rul[l[1]-1]!="Assumption"||rul[l[3]-1]!="Assumption"){throw flag+"The second and fourth rule lines must be assumptions."}if(frm[l[1]-1]!=unparse(tr[l[0]-1][0])){throw flag+"The second rule line should be the left disjunct of "+frm[l[0]-1]+"."}if(frm[l[3]-1]!=unparse(tr[l[0]-1][2])){throw flag+"The fourth rule line should be the right disjunct of "+frm[l[0]-1]+"."}if(frm[l[2]-1]!=f||frm[l[4]-1]!=f){throw flag+"The third and fifth rule lines must match the formula being derived."}var d1=dep[l[0]-1].slice(0);var d2=dep[l[2]-1].slice(0);var d3=dep[l[4]-1].slice(0);if(d2.indexOf(l[1])>=0){d2.splice(d2.indexOf(l[1]),1)}if(d3.indexOf(l[3])>=0){d3.splice(d3.indexOf(l[3]),1)}var a=d1.concat(d2,d3);a=rmDup(a);a=sorted(a);if(d.join(",")!=a.join(",")){throw flag+"dependencies are wrong.  Remember: take the dependencies of each conclusion line, discharging the relevant vE assumption, and then combine that with the dependencies of the original disjunction."}}function ckCNI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to lines "+l.join(",")+"]: ";if(l.length!=2){throw flag+"Rule must be applied to two lines."}if(t.length!=3||t[1]!=">"){throw flag+"The formula being derived must be a conditional."}if(rul[l[0]-1]!="Assumption"){throw flag+"The first rule line must be an assumption."}if(frm[l[0]-1]!=unparse(t[0])){throw flag+"The first rule line must be the antecedent of the conditional being derived."}if(frm[l[1]-1]!=unparse(t[2])){throw flag+"The second rule line must be the consequent of the conditional being derived."}var a=dep[l[1]-1].slice(0);if(a.indexOf(l[0])>=0){a.splice(a.indexOf(l[0]),1)}if(d.join(",")!=a.join(",")){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the consequent, and remove the line number of the assumed antecedent."}}function ckCNE(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to lines "+l.join(",")+"]: ";if(l.length!=2){throw flag+"Rule must be applied to two lines."}if(tr[l[0]-1].length!=3||tr[l[0]-1][1]!=">"){throw flag+"The first rule line must be a conditional."}if(frm[l[1]-1]!=unparse(tr[l[0]-1][0])){throw flag+"The second rule line must be the antecedent of the conditional on the first rule line."}if(f!=unparse(tr[l[0]-1][2])){throw flag+"The formula being derived must be the consequent of the conditional on the first rule line."}var tmp=dep[l[0]-1].concat(dep[l[1]-1]);var tmp=sorted(rmDup(tmp));var a=tmp.join(",");if(d.join(",")!=a){throw flag+"dependencies are wrong.  Remember: combine the dependencies of the two lines the rule is applied to."}}function ckNI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to lines "+l.join(",")+"]: ";if(l.length!=2){throw flag+"Rule must be applied to two lines."}if(rul[l[0]-1]!="Assumption"){throw flag+"The first rule line must be an assumption."}var uwu=unparse(tr[l[1]-1]).split("&");if(tr[l[1]-1][0]!=="#"&&uwu.length!==2&&"~"+uwu[0].trim().slice(1)!==uwu[1].trim().slice(0,-1)){throw flag+"The second rule line must be the absurdity (i.e. # or P & ~P)."}if(f!="~"+frm[l[0]-1]){throw flag+"The formula being derived must be the negation of the assumption on the first rule line."}var a=dep[l[1]-1].slice(0);if(a.indexOf(l[0])>=0){a.splice(a.indexOf(l[0]),1)}if(d.join(",")!=a.join(",")){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the absurdity, and remove the line number of the assumption."}}function ckNE(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to lines "+l.join(",")+"]: ";if(l.length!=2){throw flag+"Rule must be applied to two lines."}if(f!="#"){throw flag+"Formula being derived must be the absurdity, #, or a contradition."}if(frm[l[0]-1]!="~"+frm[l[1]-1]&&"~"+frm[l[0]-1]!=frm[l[1]-1]){throw flag+"One of lines "+l[0]+" or "+l[1]+" must be the negation of the other."}var tmp=dep[l[0]-1].concat(dep[l[1]-1]);tmp=sorted(rmDup(tmp));var a=tmp.join(",");if(d.join(",")!=a){throw flag+"dependencies are wrong.  Remember: combine the dependencies of the two lines the rule is applied to."}}function ckDN(d,f,t,r,s,l,n){var flag="[ERROR applying DN to line "+l.join(",")+"]: ";if(l.length!=1){throw flag+"Rule must be applied to one line."}if(!(frm[l[0]-1].length>=3)||frm[l[0]-1].substr(0,2)!="~~"||f!=frm[l[0]-1].substring(2)){throw flag+"Formula on line "+l[0]+" must be the double negation of the formula being derived."}var a=dep[l[0]-1].join(",");if(d.join(",")!=a){throw flag+"Dependencies are wrong.  Remember: carry down the dependencies of the line the rule is applied to."}}function ckBCI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l+"]: ";if(l.length!=2){throw flag+"Rule must be applied to two lines."}var t1=tr[l[0]-1];var t2=tr[l[1]-1];var x=match(parse("(A>B)"),t1);var u=match(parse("(B>A)"),t2);var v=match(parse("(A<>B)"),t);var w=match(parse("(B<>A)"),t);if(!x[0]||!u[0]||!v[0]){throw flag+"The formulas on lines "+l[0]+" and "+l[1]+" must be conditionals, and the formula being derived must be a biconditional."}if(clash(x[1].concat(u[1]))){throw flag+"The conditionals on lines "+l[0]+" and "+l[1]+" have to be converses of each other."}if(clash(x[1].concat(v[1]))&&clash(x[1].concat(w[1]))){throw flag+"The biconditional being derived doesn't match the conditionals on lines "+l[0]+" and "+l[1]+"."}var tmp=dep[l[0]-1].concat(dep[l[1]-1]);tmp=sorted(rmDup(tmp));var a=tmp.join(",");if(d.join(",")!=a){throw flag+"Dependencies are wrong.  Remember: carry down the dependencies of the lines the rule is applied to."}}function ckBCE(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l+"]: ";if(l.length!=1){throw flag+"Rule must be applied to one line."}var tl=tr[l[0]-1];var x=match(parse("(A<>B)"),tl);var u=match(parse("(A>B)"),t);var v=match(parse("(B>A)"),t);if(!x[0]||!u[0]||!v[0]){throw"The formula on line "+l[0]+" must be a biconditional, and the formula being derived must be a conditional."}if(clash(x[1].concat(u[1]))&&clash(x[1].concat(v[1]))){throw"The conditional being derived doesn't match the biconditional on line "+l[0]+"."}if(d.join(",")!=dep[l[0]-1].join(",")){throw flag+"Dependencies are wrong.  Remember: carry down the dependencies of the line the rule is applied to."}}function ckEFQ(d,f,t,r,s,l,n){var flag="[ERROR applying EFQ to line "+l.join(",")+"]: ";if(l.length!=1){throw flag+"Rule must be applied to one line."}if(frm[l[0]-1]!="#"){throw flag+"Formula on line "+l[0]+" must be the absurdity, '#'."}if(d.join(",")!=dep[l[0]-1].join(",")){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the line the rule is applied to."}}function ckDf(d,f,t,r,s,l,n){var flag="[ERROR applying Df to line "+l.join(",")+"]: ";if(l.length!=1){throw flag+"Rule must be applied to one line."}var tl=tr[l[0]-1];if(t.length!=3||tl.length!=3||!(tl[1]=="<>"&&t[1]=="&"||tl[1]=="&"&&t[1]=="<>")){nope()}if(t[1]=="&"){var x=match(parse("(A<>B)"),tl);if(!x[0]){nope()}var u=match(parse("((A>B)&(B>A))"),t);var v=match(parse("((B>A)&(A>B))"),t);if(!u[0]||!v[0]){nope()}if(clash(x[1].concat(u[1]))&&clash(x[1].concat(v[1]))){nope()}}if(t[1]=="<>"){var x=match(parse("((A>B)&(B>A))"),tl);if(!x[0]){nope()}var u=match(parse("(A<>B)"),t);var v=match(parse("(B<>A)"),t);if(!u[0]||!v[0]){nope()}if(clash(x[1].concat(u[1]))&&clash(x[1].concat(v[1]))){nope()}}function nope(){throw flag+"The formula being derived does not follow by Df."}var a=dep[l[0]-1].join(",");if(d.join(",")!=a){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the line the rule is applied to."}}function ckEI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l[0]+"]: ";if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}if(t.length!=2||!isQ(t[0])||t[0][1]!="E"){throw flag+"The formula being derived is not existentially quantified."}var iv=isInst(t,frm[l[0]-1]);if(iv=="_"){throw flag+"The formula on line "+l[0]+" is not an instance of the formula being derived."}var a=dep[l[0]-1].join(",");if(d.join(",")!=a){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the line the rule is applied to."}}function ckEE(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to lines "+l.join(",")+"]: ";if(l.length!=3){throw flag+"The rule is being applied to an inappropriate number of lines."}var ex=l[0]-1;if(tr[ex].length!=2||!isQ(tr[ex][0])||tr[ex][0][1]!="E"){throw flag+"The first rule line must be an existentially quantified formula."}var ass=l[1]-1;var iv=isInst(tr[ex],frm[ass]);if(rul[ass]!="Assumption"||iv=="_"){throw flag+"The second rule line is either not an assumption, or not an instance of the existential formula on the first rule line."}var cl=l[2]-1;if(frm[cl]!=f){throw flag+"The formula being derived must match the formula on the third rule line."}var freevars=[];for(var i=0;i<dep[cl].length;i++){if(dep[cl][i]-1!=ass){freevars=freevars.concat(freeVars(tr[dep[cl][i]-1]))}}freevars=freevars.concat(freeVars(tr[cl]));freevars=freevars.concat(freeVars(tr[ex]));if(freevars.indexOf(iv)>=0){throw flag+"Generalizability Failure.  The constant '"+iv+"' used in creating the instance on line "+(ass+1)+" occurs in either (i) the original existential on line "+(ex+1)+", or (ii) the formula on line "+(cl+1)+" or (iii) one of the dependencies of line "+(cl+1)+" (other than "+(ass+1)+")."}var a=dep[cl].slice(0);if(a.indexOf(ass+1)>=0){a.splice(a.indexOf(ass+1),1)}a=a.concat(dep[ex]);a=rmDup(a);a=sorted(a);if(d.join(",")!=a.join(",")){throw flag+"dependencies are wrong.  Remember: take the dependencies of the third rule line, discharge the assumption, and then combine that with the dependencies of the existential on the first rule line."}}function ckAI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l[0]+"]: ";if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}if(t.length!=2||!isQ(t[0])||t[0][1]!="A"){throw flag+"The formula being derived is not universally quantified."}var iv=isInst(t,frm[l[0]-1]);if(iv=="_"){throw flag+"The formula on the line the rule is being applied to is not an instance of the universal being derived."}var freevars=freeVars(t);if(freevars.indexOf(iv)>=0){throw flag+"Every occurrence of the constant '"+iv+"' in line "+l[0]+" has to be replaced with the variable '"+t[0][2]+"' bound by the quantifier being introduced."}freevars=[];for(var i=0;i<dep[l[0]-1].length;i++){freevars=freevars.concat(freeVars(tr[dep[l[0]-1][i]-1]))}if(freevars.indexOf(iv)>=0){throw flag+"Generalizability Failure.  The constant '"+iv+"' being generalized on occurs in one of the dependencies of line "+l[0]+"."}if(d.join(",")!=dep[l[0]-1].join(",")){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the line the rule is being applied to."}}function ckAE(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l[0]+"]: ";if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}if(tr[l[0]-1].length!=2||!isQ(tr[l[0]-1][0])||tr[l[0]-1][0][1]!="A"){throw flag+"The formula the rule is being applied to is not universally quantified."}var iv=isInst(tr[l[0]-1],f);if(iv=="_"){throw flag+"The formula being derived is not an instance of the universally quantified formula on line "+l[0]+"."}var a=dep[l[0]-1].join(",");if(d.join(",")!=a){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the line the rule is applied to."}}function ckIDI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+"]: ";if(l.length!=0){throw flag+"This rule should not be applied to any lines."}if(t.length!=3||t[1]!="="||t[0]!=t[2]){throw flag+"The formula entered is not of the form 't=t'."}if(d.length!=0){throw flag+"Lines introduced by =I should have no dependencies."}}function ckIDE(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to lines "+l.join(",")+"]: ";if(l.length!=2){throw flag+"The rule is being applied to an inappropriate number of lines."}if(tr[l[0]-1].length!=3||tr[l[0]-1][1]!="="){throw flag+"The first rule line needs to be an identity."}if(!checkID(tr[l[0]-1],tr[l[1]-1],f)){throw flag+"The formula being derived does not follow by "+r+"."}var a=dep[l[0]-1].concat(dep[l[1]-1]);a=sorted(rmDup(a));if(d.join(",")!=a.join(",")){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the two lines the rule is being applied to."}}function ckQS(d,f,t,r,s,l,n){var flag="[ERROR applying SI(QS) to line "+l[0]+"]: ";if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}var rl=l[0]-1;if(t.length!=2||t[1].length!=2||tr[rl].length!=2||tr[rl][1].length!=2){nope()}if(isU(tr[rl][0])&&isQ(tr[rl][1][0])){var rest=unparse(tr[rl][1][1]);var oq=tr[rl][1][0];var nq=flip(oq);var frm=nq+"~"+rest;if(f!=frm){nope()}}else if(isQ(tr[rl][0])&&isU(tr[rl][1][0])){var rest=unparse(tr[rl][1][1]);var oq=tr[rl][0];var nq=flip(oq);var frm="~"+nq+rest;if(f!=frm){nope()}}else{nope()}if(d.join(",")!=dep[rl].join(",")){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the line the rule is being applied to."}function nope(){throw flag+"The formula being derived does not follow by "+r+"."}function flip(q){var dic={A:"E",E:"A"};return q[0]+dic[q[1]]+q[2]+q[3]}}function ckAV(d,f,t,r,s,l,n){var flag="[ERROR applying SI(AV) to line "+l[0]+"]: ";if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}if(!isAV(tr[l[0]-1],frm[l[0]-1],f)){throw flag+"The formula being derived is not a single variable alphabetic variant of the formula on line "+l[0]+"."}if(d.join(",")!=dep[l[0]-1].join(",")){throw flag+"dependencies are wrong.  Remember: carry down the dependencies of the line the rule is being applied to."}}function mkTmp(ar){var v=ar[0][2];return mk(ar[1]);function mk(a){if(a.length==2&&isQ(a[0])){if(a[0][2]==v){return[a[0],a[1]]}else{return[a[0],mk(a[1])]}}else if(a.length==2&&isU(a[0])){return[a[0],mk(a[1])]}else if(a.length==3&&isB(a[1])){return[mk(a[0]),a[1],mk(a[2])]}else{return replace(v,a)}}function replace(x,ls){var out=[];for(var i=0;i<ls.length;i++){if(ls[i]==x){out.push("_")}else{out.push(ls[i])}}return out}}function isInst(t,s){var tmp=mkTmp(t);var b=blockedVars(tmp);var stmp=unparse(tmp);if(stmp.length!=s.length){return"_"}if(stmp.indexOf("_")<0){return"_"}var iv=s[stmp.indexOf("_")];if(b.indexOf(iv)>=0){return"_"}return s==stmp.replace(/_/g,iv)?iv:"_"}function freeVars(ar){function mk(a,v){if(a.length==2&&isQ(a[0])){v.push(a[0][2]);return mk(a[1],v)}else if(a.length==2&&isU(a[0])){return mk(a[1],v)}else if(a.length==3&&isB(a[1])){return mk(a[0],v).concat(mk(a[2],v))}else{var out=[];for(var i=0;i<a.length;i++){if(/[a-z]/.test(a[i])&&v.indexOf(a[i])<0){out.push(a[i])}}return out}}return mk(ar,[])}function checkID(id,t1,f2){var f1=unparse(t1);if(f2==f1){return false}if(f2.length!=f1.length){return false}var dic=[id[0],id[2]];function mk(a,v){if(a.length==2&&isQ(a[0])){v.push(a[0][2]);return a[0]+mk(a[1],v)}else if(a.length==2&&isU(a[0])){return a[0]+mk(a[1],v)}else if(a.length==3&&isB(a[1])){return"("+mk(a[0],v)+a[1]+mk(a[2],v)+")"}else{var out="";for(var i=0;i<a.length;i++){if(a[i]==dic[0]&&v.indexOf(a[i])==-1){out=out+"_"}else{out=out+a[i]}}return out}}var tmp=mk(t1,[]);if(tmp.indexOf("_")==-1){return false}for(var i=0;i<tmp.length;i++){if(tmp[i]=="_"){if(f2[i]!=dic[0]&&f2[i]!=dic[1]){return false}}else if(tmp[i]!=f2[i]){return false}}return true}function isAV(tree,f1,f2){if(f1.length!=f2.length){return false}var avlst=mkAVList(tree);var v="";for(var i=0;i<avlst.length;i++){v=f2[avlst[i][1].indexOf("_")];if(f2==avlst[i][1].replace(/_/g,v)&&avlst[i][0].indexOf(v)<0){return true}}return false}function mkAVList(tree){var loc=getQLoc(tree);var out=[];var x="";var b=[];for(var i=0;i<loc.length;i++){x=mkAVtmp(getTreeAt(tree,loc[i]));b=blockedVars(x[1]).concat(freeVars(x[1]));x=insertTmp(tree,strAVtmp(x),loc[i]);out.push([b,x])}return out}function getQLoc(tree){var loc=[];gt(tree,[]);return loc;function gt(a,y){if(a.length==2&&isQ(a[0])){loc.push(y.slice(0));y.push(1);gt(a[1],y.slice(0))}else if(a.length==2&&isU(a[0])){y.push(1);gt(a[1],y.slice(0))}else if(a.length==3&&isB(a[1])){y.push(0);gt(a[0],y.slice(0));y.pop();y.push(2);gt(a[2],y.slice(0))}}}function mkAVtmp(tree){return[tree[0][0]+tree[0][1]+"_"+tree[0][3],mkTmp(tree)]}function strAVtmp(avtmp){return avtmp[0]+unparse(avtmp[1])}function getTreeAt(tree,loc){for(var i=0;i<loc.length;i++){tree=tree[loc[i]]}return tree}function blockedVars(tmp){blocked=[];gt(tmp);return blocked;function gt(t){if(t.length==2&&isQ(t[0])){if(hasblank(t[1])){blocked.push(t[0][2])}}else if(t.length==2&&isU(t[0])){gt(t[1])}else if(t.length==3&&isB(t[1])){gt(t[0]);gt(t[2])}}function hasblank(a){test=false;for(var i=0;i<a.length;i++){if(a[i]instanceof Array){test=test||hasblank(a[i])}else{test=test||a[i]=="_"}}return test}}function insertTmp(tree,savtmp,loc){return go(tree,[]);function go(ar,l){if(smLoc(l,loc)){return savtmp}if(ar.length==2&&(isQ(ar[0])||isU(ar[0]))){return ar[0]+go(ar[1],l.concat([1]))}if(ar.length==3&&isB(ar[1])){return"("+go(ar[0],l.concat([0]))+ar[1]+go(ar[2],l.concat([2]))+")"}else{return ar.join("")}}function smLoc(l1,l2){if(l1.length!=l2.length){return false}for(var i=0;i<l1.length;i++){if(l1[i]!=l2[i]){return false}}return true}}function ckSI(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line(s) "+l.join(",")+"]: ";if(s.length==0){throw flag+"The rule is not recognized."}if(l.length!=s.length-1){throw flag+"The rule is being applied to an inappropriate number of lines."}if(s.length==1){var x=match(parse(s[0]),t);if(!x[0]){nope()}if(clash(x[1])){nope()}if(d.length!=0){throw flag+"dependencies are wrong."}}if(s.length==2){var x=match(parse(s[0]),tr[l[0]-1]);if(!x[0]){nope()}var y=match(parse(s[1]),t);if(!y[0]){nope()}if(clash(x[1].concat(y[1]))){nope()}var a=dep[l[0]-1].join(",");if(d.join(",")!=a){throw flag+"dependencies are wrong."}}if(s.length==3){var x=match(parse(s[0]),tr[l[0]-1]);if(!x[0]){nope()}var y=match(parse(s[1]),tr[l[1]-1]);if(!y[0]){nope()}var z=match(parse(s[2]),t);if(!z[0]){nope()}if(clash(x[1].concat(y[1],z[1]))){nope()}var a=dep[l[0]-1].concat(dep[l[1]-1]);var a=sorted(rmDup(a));if(d.join(",")!=a.join(",")){throw flag+"dependencies are wrong."}}function nope(){if(["SI(DS1)","SI(DS2)","SI(MT)"].indexOf(r)>=0){throw flag+"The formula being derived does not follow by "+r+".  Perhaps check that the two lines the rule is applied to are listed in the right order."}else{throw flag+"The formula being derived does not follow by "+r+"."}}}function ckSIbi(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l[0]+"]: ";if(s.length==0){throw flag+"The rule is not recognized."}if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}var m1=match(parse(s[0]),t);if(!m1[0]){m1=match(parse(s[1]),t);var m2=match(parse(s[0]),tr[l[0]-1])}else{var m2=match(parse(s[1]),tr[l[0]-1])}if(!m1[0]||!m2[0]){nope()}if(clash(m1[1].concat(m2[1]))){nope()}if(d.join(",")!=dep[l[0]-1].join(",")){throw flag+"dependencies are wrong."}function nope(){throw flag+"The formula being derived does not follow by "+r+"."}}function ckCom(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l[0]+"]: ";if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}var cns=["&","v","<>"];var c1=t[1];var c2=tr[l[0]-1][1];if(c1==undefined||c2==undefined||c1!=c2){nope()}if(cns.indexOf(c1)<0){throw flag+c1+" is not a commutative connective."}var m1=match(parse("(A"+c1+"B)"),t);var m2=match(parse("(B"+c1+"A)"),tr[l[0]-1]);if(!m1[0]||!m2[0]||clash(m1[1].concat(m2[1]))){nope()}if(d.join(",")!=dep[l[0]-1].join(",")){throw flag+"dependencies are wrong."}function nope(){throw flag+"The formula being derived does not follow by "+r+"."}}function ckSDN1(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l[0]+"]: ";if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}var c=t[1];var c2=tr[l[0]-1][1];if(c==undefined||c2==undefined||c!=c2){nope()}var templates=["(A"+c+"B)","(~~A"+c+"B)","(A"+c+"~~B)","(~~A"+c+"~~B)"];var dmatch=get_match(templates,t);var fmatch=get_match(templates,tr[l[0]-1]);if(fmatch.length==0||dmatch.length==0){nope()}if(clash(fmatch[1].concat(dmatch[1]))){nope()}if(d.join(",")!=dep[l[0]-1].join(",")){throw flag+"dependencies are wrong."}function nope(){throw flag+"The formula being derived does not follow by "+r+"."}}function ckSDN2(d,f,t,r,s,l,n){var flag="[ERROR applying "+gRul(r)+" to line "+l[0]+"]: ";if(l.length!=1){throw flag+"The rule is being applied to an inappropriate number of lines."}var c=t[1][1];var c2=tr[l[0]-1][1][1];if(c==undefined||c2==undefined||c!=c2||t[0]!="~"||tr[l[0]-1][0]!="~"){nope()}var templates=["~(A"+c+"B)","~(~~A"+c+"B)","~(A"+c+"~~B)","~(~~A"+c+"~~B)"];var dmatch=get_match(templates,t);var fmatch=get_match(templates,tr[l[0]-1]);if(fmatch.length==0||dmatch.length==0){nope()}if(clash(fmatch[1].concat(dmatch[1]))){nope()}if(d.join(",")!=dep[l[0]-1].join(",")){throw flag+"dependencies are wrong."}function nope(){throw flag+"The formula being derived does not follow by "+r+"."}}function get_match(templates,tree){var m=[];for(var i=0;i<templates.length;i++){var x=match(parse(templates[i]),tree);if(x[0]){m=x}}return m}function match(t1,t2){var a=["A","B","C"];var out=[];function foo(x,y){for(var i=0;i<x.length;i++){if(x[i]instanceof Array&&y[i]instanceof Array){if(!foo(x[i],y[i])){return false}}else if(a.indexOf(x[i])>=0){out.push([a[a.indexOf(x[i])],unparse(y)])}else if(x[i]!=y[i]){return false}}return true}var t=foo(t1,t2);if(t){t=!clash(out)}return t?[t,out]:[t,[]]}function clash(ar){var a1=ar[0];ar=ar.slice(1);if(ar.length==0){return false}for(var i=0;i<ar.length;i++){if(ar[i][0]==a1[0]&&ar[i][1]!=a1[1]){return true}}return clash(ar)}function get_seq(r){switch(r){case"SI(DS1)":return"(AvB),~A,B".split(",");case"SI(DS2)":return"(AvB),~B,A".split(",");case"SI(MT)":return"(A>B),~B,~A".split(",");case"SI(PMI1)":return"A,(B>A)".split(",");case"SI(PMI2)":return"~A,(A>B)".split(",");case"SI(DN+)":return"A,~~A".split(",");case"SI(DeM1)":return"~(A&B),(~Av~B)".split(",");case"SI(DeM2)":return"~(AvB),(~A&~B)".split(",");case"SI(DeM3)":return"~(~Av~B),(A&B)".split(",");case"SI(DeM4)":return"~(~A&~B),(AvB)".split(",");case"SI(Imp)":return"(A>B),(~AvB)".split(",");case"SI(NegImp)":return"~(A>B),(A&~B)".split(",");case"SI(Dist1)":return"(A&(BvC)),((A&B)v(A&C))".split(",");case"SI(Dist2)":return"(Av(B&C)),((AvB)&(AvC))".split(",");case"SI(LEM)":return"(Av~A)".split(",");default:return[]}}function disp(id){var menu_items=["appm","repm","expm","refm"];var menu_contents=["prbt","appt","rept","expt","reft"];var proof_started=cnt.length>0||gls.length>0;for(var i=0;i<menu_items.length;i++){document.getElementById(menu_items[i]).style.backgroundColor="#DDDDDD"}for(var i=0;i<menu_contents.length;i++){document.getElementById(menu_contents[i]).style.display="none"}var show_table=id=="app"&&!proof_started?"prbt":id+"t";document.getElementById(show_table).style.display="block";document.getElementById(id+"m").style.backgroundColor="white"}function showSI(id){var d={rul:"SI1",rulr:"SI2"};var el=document.getElementById(id);var x=document.getElementById(d[id]);if(el.options[el.selectedIndex].value=="SI/TI"){x.style.display="block"}else{x.style.display="none"}}function exp(x){var el=document.getElementById(x);var tr=document.getElementById(x+"trigger");var dic={sync:"Syntax",srulc:"Rules for Sentential Logic",qrulc:"Rules for Quantificational Logic"};if(el.style.display=="none"||el.style.display==""){el.style.display="block";tr.innerHTML="[–] "+dic[x]}else{el.style.display="none";tr.innerHTML="[+] "+dic[x]}}var dep=[];var cnt=[];var frm=[];var tr=[];var rul=[];var lin=[];var gls=[];function get_userproblem(){var prem=document.getElementById("premises").value.replace(/ /g,"");var premises=prem==""?[]:prem.split(",");var conclusion=document.getElementById("conclusion").value.replace(/ /g,"");try{put_problem(premises,conclusion)}catch(err){return errmess([1],err)}}function put_problem(premises,conclusion){var p_lines=[];try{var goal=check_goal(conclusion)}catch(err){clearall();throw"ERROR: conclusion is not well formed."}for(var i=0;i<premises.length;i++){try{var line=check_line((i+1).toString(),premises[i],parse(premises[i]),"Premise","",i);p_lines.push(line)}catch(err){throw"ERROR: one of the premises is not well formed."}}for(var i=0;i<p_lines.length;i++){append_line(p_lines[i].d,p_lines[i].f,p_lines[i].t,p_lines[i].r,p_lines[i].l,p_lines[i].n)}insert_goal(goal);errmess([0],"");disp("app")}function get_line(){var d=document.getElementById("dep").value.replace(/ /g,"");var f=document.getElementById("frm").value.replace(/ /g,"");var t=parse(f);var r=document.getElementById("rul").value;var l=document.getElementById("lin").value.replace(/ /g,"");var n=cnt.length;if(r=="SI/TI"){r=document.getElementById("SI1").value}try{var line=check_line(d,f,t,r,l,n)}catch(err){return errmess([1],err)}append_line(line.d,line.f,line.t,line.r,line.l,line.n);errmess([0],"")}function check_line(d,f,t,r,l,n){if(t.length==0){f="("+f+")";t=parse(f)}ckSyn(d,f,t,l);d=sorted(rmDup(mkIntArr(d)));l=mkIntArr(l);ckRest(d,f,t,r,l,n);return{d:d,f:f,t:t,r:r,l:l,n:n}}function append_line(d,f,t,r,l,n){dep.push(d);frm.push(f);tr.push(t);rul.push(r);lin.push(l);cnt.push(n+1);var table=document.getElementById("drvt");var row=mkRow(cnt.length-1);table.appendChild(row);clear_appt()}function delete_previous(){if(cnt.length==0){return errmess([1],"ERROR: no lines to delete.")}else if(rul[rul.length-1]=="Premise"){return errmess([1],"ERROR: no lines to delete. Premise lines cannot be deleted.  Reload the page to start a new proof if you entered the premises incorrectly.")}else{var e=document.getElementById("drvt");e.deleteRow(e.rows.length-1);dep.pop();cnt.pop();frm.pop();tr.pop();rul.pop();lin.pop()}if(cnt.length==0&&gls.length==0){clear_appt();clear_prbt();disp("app")}errmess([0],"")}function get_goal(){var f=document.getElementById("gfrm").value.replace(/ /g,"");try{var goal=check_goal(f)}catch(err){return errmess([1],err)}insert_goal(goal)}function check_goal(f){var t=parse(f);if(t.length==0){f="("+f+")";t=parse(f);if(t.length==0){throw"ERROR: goal/conclusion formula is not well formed: "+f}}return f}function insert_goal(f){var clar=["depc","cntc","frmc","rulc"];var table=document.getElementById("goalt");var row=table.insertRow(0);var tdar=new Array(4);for(var i=0;i<4;i++){tdar[i]=document.createElement("td");tdar[i].className=clar[i]}var t1=document.createTextNode("Goal:");var t2=document.createTextNode(padBC(f));tdar[0].appendChild(t1);tdar[2].appendChild(t2);for(var i=0;i<4;i++){row.appendChild(tdar[i])}errmess([0],"");document.getElementById("gfrm").value="";gls.push(f)}function delete_goal(){var table=document.getElementById("goalt");if(gls.length==1){return errmess([1],"ERROR: No subgoals to delete.  Cannot delete the main goal (conclusion) of the argument.")}else{table.deleteRow(0);gls.pop()}if(gls.length==0&&cnt.length==0){clear_appt();clear_prbt();disp("app")}errmess([0],"")}function load_line(){var n=parseInt(document.getElementById("rl").value.replace(/ /g,""),10);if(isNaN(n)||n>cnt.length||n<1){return errmess([1],"ERROR: There is no line number "+n+" in the proof.")}n=n-1;if(rul[n]=="Premise"){return errmess([1],"ERROR: premise lines cannot be edited.  Reload the page to start a new proof if you entered the premises incorrectly.  Alternatively, export the proof as its stands, edit the premise, and then import the edited proof.")}document.getElementById("depr").value=dep[n].join(",");document.getElementById("frmr").value=frm[n];if(rul[n].indexOf("SI")==0){document.getElementById("rulr").value="SI/TI";document.getElementById("SI2").style.display="block";document.getElementById("SI2").value=rul[n]}else{document.getElementById("rulr").value=rul[n];document.getElementById("SI2").style.display="none"}document.getElementById("linr").value=lin[n].join(",");errmess([0],"")}function rep_line(){var n=parseInt(document.getElementById("rl").value.replace(/ /g,""),10);var d=document.getElementById("depr").value.replace(/ /g,"");var f=document.getElementById("frmr").value.replace(/ /g,"");var t=parse(f);var r=document.getElementById("rulr").value;var l=document.getElementById("linr").value.replace(/ /g,"");if(n>cnt.length||n<1){errmess([1],"ERROR: No line number "+n.toString()+" to replace")}if(r=="SI/TI"){r=document.getElementById("SI2").value}n-=1;try{var line=check_line(d,f,t,r,l,n)}catch(err){return errmess([1,n+1],"There is a problem with the replacement for line "+(n+1)+" you entered.  The error message concerning it is:<br /><br />"+err)}dep[n]=line.d;frm[n]=line.f;tr[n]=line.t;rul[n]=line.r;lin[n]=line.l;var table=document.getElementById("drvt");var row=mkRow(n);table.removeChild(table.childNodes[n]);table.insertBefore(row,table.childNodes[n]);for(var i=n+1;i<cnt.length;i++){try{ckRest(dep[i],frm[i],tr[i],rul[i],lin[i],i)}catch(err){return errmess([1,i+1],"There is a problem with proof line "+(i+1)+".  The error message concerning it is:<br /><br />"+err)}}errmess([0],"");clear_rept()}function export_proof(){if(cnt.length==0){return errmess([1],"ERROR: no proof to export.")}var plain=document.getElementById("plain").checked;var pretty=document.getElementById("pretty").checked;var latex=document.getElementById("latex").checked;var odep=dep.map(function(a){return a.join(",")});var ocnt=cnt.map(function(a){return"("+a.toString()+")"});var ofrm=plain?frm.map(padBC):"";ofrm=pretty?frm.map(function(a){return padBC2(richardify(a))}):ofrm;ofrm=latex?frm.map(function(a){return latexify(richardify(a))}):ofrm;var orul=pretty||latex?rul.map(gRul):rul.slice(0);var olin=lin.map(function(a){return a.join(",")});var ogl=plain?padBC(gls[0]):"";ogl=pretty?function(a){return padBC2(richardify(a))}(gls[0]):ogl;ogl=latex?function(a){return latexify(richardify(a))}(gls[0]):ogl;var pre="";var proof="";var premises=get_premises();if(plain||pretty){pre+="Problem: ";for(var i=0;i<premises.length;i++){pre+=i==premises.length-1?ofrm[i]:ofrm[i]+", "}pre=pre+" ⊢ "+ogl+"\r\n\r\n";pad(odep,max(odep));pad(ocnt,max(ocnt));pad(ofrm,max(ofrm)+2);for(var i=0;i<cnt.length;i++){if(olin[i].length==0){proof+=odep[i]+ocnt[i]+ofrm[i]+orul[i]+"\r\n"}else{proof+=odep[i]+ocnt[i]+ofrm[i]+olin[i]+"  "+orul[i]+"\r\n"}}}if(latex){pre+="\\noindent Problem: $";for(var i=0;i<premises.length;i++){pre+=i==premises.length-1?ofrm[i]:ofrm[i]+", "}pre+=" \\vdash "+ogl+"$\r\n\r\n";proof="\\noindent\\begin{tabular}{ l l l l }\r\n";orul=orul.map(lxrul);for(var i=0;i<cnt.length;i++){if(olin[i].length==0){proof+=odep[i]+" & "+ocnt[i]+" & $"+ofrm[i]+"$ & "+orul[i]+"\\\\\r\n"}else{proof+=odep[i]+" & "+ocnt[i]+" & $"+ofrm[i]+"$ & "+olin[i]+" "+orul[i]+"\\\\\r\n"}}proof=proof+"\\end{tabular}"}document.getElementById("importarea").value=pre+proof;function lxrul(s){var out="";var test="";for(var i=0;i<s.length;i++){test=utox(s[i]);if(test!=s[i]){test="$"+test+"$"}out+=test}return out}}function import_proof(){var proof=document.getElementById("importarea").value;if(proof.indexOf("Paste a previously")>=0){return errmess([1],"ERROR: paste a proof into the textarea first.")}clearall();document.getElementById("drvt").innerHTML="";document.getElementById("goalt").innerHTML="";var cols=[dep,cnt,frm,tr,rul,lin];var tmp=next_line(proof);var line=[];var d="";var f="";var t=[];var r="";var l="";var n="";while(tmp[0].indexOf("Problem: ")!=0&&proof.length!=0){proof=tmp[1];tmp=next_line(proof)}if(proof.length==0){return errmess([1],'ERROR: proofs must begin with a problem line.  Something like "Problem: (P>Q), P ⊢ Q"')}try{var problem=get_problem(tmp[0])}catch(err){return errmess([1],err)}insert_goal(problem[1]);while(proof.length!=0&&(tmp[0].length==0||tmp[0][0]!=" "&&!isInt(tmp[0][0]))){proof=tmp[1];tmp=next_line(proof)}if(proof.length==0){return nope()}tmp=next_line(proof);while(tmp[0].length!=0){line=tmp[0].split("  ").filter(fltr);line=line.map(function(x){return x.replace(/ /g,"")});proof=tmp[1];tmp=next_line(proof);if(line.length==5){d=line[0];n=parseInt(line[1].substring(1,line[1].length-1),10);f=line[2];r=line[4];t=parse(f);l=line[3]}else if(line.length==4){var f=0;for(var i=0;i<line.length;i++){if(parse(line[i]).length!=0){f=i;break}}if(f==1){d="";n=parseInt(line[0].substring(1,line[0].length-1),10);f=line[1];r=line[3];t=parse(f);l=line[2]}else if(f==2){d=line[0];n=parseInt(line[1].substring(1,line[1].length-1),10);f=line[2];r=line[3];t=parse(f);l=""}else{return nope()}}else if(line.length==3){d="";n=parseInt(line[0].substring(1,line[1].length-1),10);f=line[1];t=parse(f);r=line[2];l=""}else{return nope()}try{var pline=check_line(d,f,t,r,l,n-1)}catch(err){return errmess([1],"ERROR: There is a problem with line "+n+" in the proof you are attempting to import.  The error message concerning it is:<br/><br/>"+err)}if(pline.r=="Premise"&&problem[0].indexOf(pline.f)<0){return errmess([1],"ERROR: Your proof contains the following formula as a premise on line "+(pline.n+1)+": "+f+". This is not among the premises in the problem you entered.  Problem is:<br/>"+problem[0].join(",")+" ⊢ "+problem[1])}append_line(pline.d,pline.f,pline.t,pline.r,pline.l,pline.n);errmess([0],"")}check_proof();document.getElementById("importarea").value='Paste a previously exported proof (in plain notation) here and import it by clicking the button. NOTE: you can edit a proof here, but you need to be careful about formatting.  E.g. make sure the proof begins with a "Problem: " line, that formulas contain outermost parentheses, and that there are at least two spaces separating each "column" of the proof, with no double spaces elsewhere.';function testr(str){var t=["∀","∃","→","↔","⊥"];for(var i=0;i<t.length;i++){if(str.indexOf(t[i])>=0){return true}}return false}function fltr(x){if(x.length==0){return false}hascontent=false;for(var i=0;i<x.length;i++){if(x[i]!=" "){hascontent=true}}return hascontent}function writeProof(){var table=document.getElementById("drvt");for(var i=0;i<cnt.length;i++){table.appendChild(mkRow(i))}}function nope(){clearall();document.getElementById("drvt").innerHTML="";document.getElementById("goalt").innerHTML="";errmess([1],"ERROR: Something is wrong with the formatting of the proof you entered.  Remember to include outermost parentheses in formulas.")}function next_line(str){var x=str.indexOf("\n");if(x!=-1){return[str.substring(0,x),str.substring(x+1)]}else{return[str,""]}}}function check_proof(){if(cnt.length==0){return errmess([1],"ERROR: No proof to check")}for(var i=0;i<cnt.length;i++){try{ckRest(dep[i],frm[i],tr[i],rul[i],lin[i],i)}catch(err){return errmess([1,i+1],"There is a problem with proof line "+(i+1)+".  The error message concerning it is:<br /><br />"+err)}}var prems=dep[dep.length-1];for(var i=0;i<prems.length;i++){if(rul[prems[i]-1]!="Premise"){return errmess([1],"WARNING: the final line of your proof depends on line "+prems[i]+", which is not a Premise!")}}if(frm[frm.length-1]!=gls[0]){return errmess([1],"WARNING: the last line of you proof does not match the conclusion you are aiming for.  Last line should be: "+gls[0])}return errmess([0],"Proof checks out!")}function mkRow(j){var tr=document.createElement("tr");var tdar=new Array(4);var txar=new Array(4);var clar=["depc","cntc","frmc","rulc"];for(var i=0;i<4;i++){tdar[i]=document.createElement("td");tdar[i].className=clar[i]}txar[0]=document.createTextNode(dep[j].join(","));txar[1]=document.createTextNode("("+cnt[j]+")");txar[2]=document.createTextNode(padBC(frm[j]));txar[3]=document.createTextNode(lin[j].join(",")+"  "+rul[j]);for(var i=0;i<4;i++){tdar[i].appendChild(txar[i]);tr.appendChild(tdar[i])}return tr}function errmess(n,mess){var erel=document.getElementById("errord");var proof=document.getElementById("drvt");if(n[0]){erel.style.border="solid 1px #FF0000";erel.style.backgroundColor="#FF9999";erel.innerHTML=mess;for(var i=0;i<proof.childNodes.length;i++){proof.childNodes[i].style.color="black"}if(n.length>1){proof.childNodes[n[1]-1].style.color="red"}}else{erel.style.border="solid 1px #B4BAEA";erel.style.backgroundColor="#F0F4FF";erel.innerHTML=mess;for(var i=0;i<proof.childNodes.length;i++){proof.childNodes[i].style.color="black"}}}function clear_appt(){document.getElementById("dep").value="";document.getElementById("frm").value="";document.getElementById("rul").value="Assumption";document.getElementById("SI1").value="SI(DS1)";document.getElementById("SI1").style.display="none";document.getElementById("lin").value=""}function clear_prbt(){document.getElementById("premises").value="";document.getElementById("conclusion").value=""}function clear_rept(){document.getElementById("rl").value="";document.getElementById("depr").value="";document.getElementById("frmr").value="";document.getElementById("linr").value="";document.getElementById("rulr").value="Assumption";document.getElementById("SI2").value="SI(DS1)";document.getElementById("SI2").style.display="none"}function clearall(){dep=[];cnt=[];frm=[];tr=[];rul=[];lin=[];gls=[]}function get_premises(){prems=[];for(var i=0;i<cnt.length;i++){if(rul[i]=="Premise"){prems.push(i)}}return prems}function get_problem(str){str=str.replace("Problem: ","");str=str.replace("⊢",",");str=str.replace(/ /g,"");str=str.split(",");str=str.filter(function(x){return x.length!=0});var tmp="";for(var i=0;i<str.length;i++){if(parse(str[i]).length==0){throw"ERROR: the following formula in the Problem line is ill-formed: "+str[i]+". Make sure outermost parentheses are included."}}return[str.slice(0,str.length-1),str[str.length-1]]}function ckSyn(d,f,t,l){if(d!=""&&!ckc(d)){throw"ERROR: dependencies are malformed."}if(t.length==0){throw"ERROR: Formula is malformed."}var x="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz()~&<>=#";for(var i=0;i<f.length;i++){if(x.indexOf(f[i])<0){throw"ERROR: the formula you entered contains the unrecognized character '"+f[i]+"'.  See the syntax guide under the Reference tab."}}if(!(l=="")&&!ckc(l)){throw"ERROR: Rule lines are malformed"}}function ckRest(d,f,t,r,l,n){var x=0;if((x=oob(l,n))>0){throw"ERROR: Rule line "+x+" is out of bounds. Rules must be applied to preceding lines."}s=get_seq(r);if(r=="Premise"||r=="Assumption"){ckPA(d,f,t,r,s,l,n)}else if(r=="&I"){ckCJI(d,f,t,r,s,l,n)}else if(r=="&E"){ckCJE(d,f,t,r,s,l,n)}else if(r=="vI"){ckDJI(d,f,t,r,s,l,n)}else if(r=="vE"){ckDJE(d,f,t,r,s,l,n)}else if(r==">I"){ckCNI(d,f,t,r,s,l,n)}else if(r==">E"){ckCNE(d,f,t,r,s,l,n)}else if(r=="~I"){ckNI(d,f,t,r,s,l,n)}else if(r=="~E"){ckNE(d,f,t,r,s,l,n)}else if(r=="DN"){ckDN(d,f,t,r,s,l,n)}else if(r=="<>I"){ckBCI(d,f,t,r,s,l,n)}else if(r=="<>E"){ckBCE(d,f,t,r,s,l,n)}else if(r=="Df"){ckDf(d,f,t,r,s,l,n)}else if(r=="EFQ"){ckEFQ(d,f,t,r,s,l,n)}else if(r=="EI"){ckEI(d,f,t,r,s,l,n)}else if(r=="EE"){ckEE(d,f,t,r,s,l,n)}else if(r=="AI"){ckAI(d,f,t,r,s,l,n)}else if(r=="AE"){ckAE(d,f,t,r,s,l,n)}else if(r=="=I"){ckIDI(d,f,t,r,s,l,n)}else if(r=="=E"){ckIDE(d,f,t,r,s,l,n)}else if(r=="SI(Com)"){ckCom(d,f,t,r,s,l,n)}else if(r=="SI(QS)"){ckQS(d,f,t,r,s,l,n)}else if(r=="SI(AV)"){ckAV(d,f,t,r,s,l,n)}else if(r=="SI(SDN1)"){ckSDN1(d,f,t,r,s,l,n)}else if(r=="SI(SDN2)"){ckSDN2(d,f,t,r,s,l,n)}else if(r.indexOf("DeM")>0||r.indexOf("Imp")>0||r.indexOf("Dist")>0){ckSIbi(d,f,t,r,s,l,n)}else if(r.indexOf("SI")==0){ckSI(d,f,t,r,s,l,n)}else{throw"ERROR: The rule "+r+" you entered is not recognized."}}function oob(ar,n){for(var i=0;i<ar.length;i++){if(ar[i]>n){return ar[i]}}return 0}function ckc(s){var n=["0","1","2","3","4","5","6","7","8","9"];var st=false;var c="";for(var i=0;i<s.length;i++){c=s[i];if(n.indexOf(c)>=0){st=true}else if(c==","&&st){st=false}else{return false}}return st}function sorted(a){return a.sort(function(a,b){return a-b})}function mkIntArr(s){if(s==""){return[]}else{var a=s.split(",");return a.map(function(x){return parseInt(x,10)})}}function max(ar){var n=0;for(var i=0;i<ar.length;i++){if(ar[i].length>n){n=ar[i].length}}return n}function pad(ar,n){for(var i=0;i<ar.length;i++){while(ar[i].length<n){ar[i]+=" "}ar[i]+="  "}}function isInt(s){var n=["0","1","2","3","4","5","6","7","8","9"];for(var i=0;i<s.length;i++){if(n.indexOf(s[i])<0){return false}}return!(s.length==0)}function rmDup(a){return a.filter(function(el,pos){return a.indexOf(el)==pos})}
